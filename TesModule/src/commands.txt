git config --list --global  показывает как подписан в глобальном уровне git
cat ~/.gitconfig - показывает сам файл гит конфиг домашней дерректории
git config -h - выводит сами команды гита и их описание
git help и затем любая команда - покажет объяснние в справочнике, что означает эта команда
git status - показывает какие файлы не отслеживаются. Если это игнорируемые файлы, то мы на них не обращаем внимания. Остальные
файлы нужно добавить в индекс. Для этого см ниже

git add путь - добавляет файл в индекс. При этом указываем полный путь который высветился в коммандной сторке после команды git status
git reset путь - уадалит указанный файл из индекса.
git diff - показывает изменения, которые были сделаны
git commit - фиксирует изменения в репозитории. Перекидывает нас в редактор, где мы пишем заголовок коммита и описание.
git commit -m 'пишем комментарий к коммиту в одинарных кавычках'- позволяет сдлеать комит без редактора. Так можно делвть, если изменения маленькие.
git show - показывает последний коммит HEAD-а
git show --pretty=fuller - покажет больше информации по последнему коммиту в том числе автора и коммиттера т.к. они иногда могут быть разными
git show название ветки или идентификатор - выводит последний коммит указанной ветки или идентификатора
git show HEAD~ - покажет коммит на один шаг назад(т.е. родителя) от HEAD. А ТАКЖЕ ПОКАЖЕТ РАЗЛИЧИЯ.
Вместо HEAD для сокращения можно ставить @
git show HEAD~~ - на два шага назад. Сколько тильд(~) поставим на столько шагов назад и передвинемся. Чтобы много тильд не ставить моно писать так ~3 - значит на три шага назад.


git commit -am 'Заголовок и\или короткое описание коммита' - сразу передает в индекс и одновременно коммитит в репозиторий
Можно писать git commit --all -m ,но -am это сокращённо

git reset HEAD название файла - если после изменений в файле мы добавили его в индекс, то воспользовавшись этой командой мы удалим указанный файл из индекса

git remote show origin - показывает данные об удалённом репозитории
git push origin main - отправка исзменений в удаленный репозиторий на ветку main
git branch - показывает ветку в которой мы работаем
git branch -v - показывает ветку в которой мы работаем и информация о коммите на который она указывает. А также показывает все существующие ветки.
Ветка - это ссылка на коммит поэтому при создании новой ветки она изначально тоже будет ссылаться на тот же коммит
==================================================================
СОЗДАНИЕ ВЕТОК
git branch название ветки - создаёт новую ветку
git checkout название ветки - переключает на указанную ветку
git checkout -b название ветки - создаёт ветку и сразу же переключает нас на неё
============================================================
УДАЛЕНИЕ ВЕТОК И УДАЛЁННЫЕ РЕПОЗИТОРИИ(РАБОТАЮЩИЕ УДАЛЁННО)
git branch -d название ветки - удаляет смердженную ветку, если мы закончили например работу и эта ветка уже нам больше не нужна
git branch -D название ветки (сокращенная запись опции --delete --force) -  удаляет НЕ смердженную ветку принудительно, независимо от её статуса мерджа. Тогда коммиты не будут пррисоединены ни к одной ветке - такие коммиты называются недостижимыми и со временем гит удалит их совсем. Если ветка тупиковая и коммиты не нужны это хороший вариант.
git branch -a(сокращённая запись опции --all) - показывает все ветки, удалённые(работающие удалённо) и локальные
git push имя удалённого репозитория -d имя удалённой ветки - удаляет ветку на удалённом репозитории

====================================================
Если во время разработки нас попросили переключиться в другую ветку, то после вызова команды git checkout название ветки - вылетит ошибка т.к. в классике мы должны закомитить изменения. Но если нас попросили переключиться, когда наши изменения не годятся для создаия комита, тогда можне применить следующу команду:
git checkout --force название ветки - НО при этом все изменени исчезнут т.к. перезапишутся той веткой в котроую мы переключаемся.
Лучше использовать команду:
git stash - позволяет нам НЕ потерять изменения которые не подходят для коммита, в то время когда нам нужно прейти на другую ветку. Позволяет сохранить измененения в особом архиве и не сохранять их в файле. Затем вернувшись мы можем вернуть эти измемнения применив команду ниже.
git stash pop - позволит вернуть изменения из хранилища, когда мы вернёмся в предыдущую ветку
!!!! НУжно быть внимательным в какой ветке мы находимся, чтобы вызывать git pop именно в той ветке в которй мы работали ранее и вызвали git stash. Иначе измененения вылезут в другой ветке, а она в свою очередь может отличаться от той и тогда будет сильная путаница.
===================================================
ПЕРЕНОС ВЕТОК
Если например мы сделали на основной ветке, например main, несколько коммиттов, а затем поняли, что зря сделали их в основной ветке.
То логически нам нужно, чтобы эти коммиты были на другой ветке, а ветку main в таком случае нам нужно перенести на коммит до этих коммитов. Соотвественно нам нужно ветку main перенести.
Для этого мы создаём отдельную ветку, например fix. После этого fix и main ссылаются на один коммит. Затем мы переключаемся на fix и пересоздаём ветку main с указанием короткого идентификатора коммита. Вводим команду:
git branch -f main короткий идентификатор
!!!ВАЖНО Возникает вопрос как узнать какой идентификатор написать, ведь это не так просто т.к. перенос main нужно сделать на несколько коммитов назад, откуда мы можем узнать идентификатор, например какого-нибудь коммита в пятом колене ниже. Для этого применяем команду для просмотра ВСЕХ идентификаторов ВСЕХ коммитов:
git log --oneline - выводит коммиты с короткими идентификаторами
git log --pretty=oneline - выводит коммиты с полными идентификаторами
git log название ветки --oneline - выводит коммиты только указанной ветки

Если же нам например захотелось перенести main на коммит на который указывает fix, то мы пишем команду:
git branch -f main fix   (на самом деле можно указать идентификатор, это одно и тоже в данном случае - основа это идентификатор)
git checkout -B main идентификатор - создаёт ветку или, если она уже создана, то переносит ветку, в данном случае main, на нужный нам коммит и переключается на неё
=========================================
СЛИЯНИЕ ВЕТОК, УДАЛЕНИЕ - удаление рассмотрено выше в соответствующем разделе.
git merge название ветки - присоединит ветку, НА КОТОРОЙ МЫ НАХОДИМСЯ к ветке, указанной в команде. Соответственно предварительно при необходимости нужно переключиться на нужную ветку. Т.е. на самом деле, мы просто переносим ссылку.
git branch -f название перенесённой ветки ORIG_HEAD - вернёт слитую ветку обратно на предыдущую позицию. При этом нужно переключиься на другую ветку, например на ту к котрой мы слили.
По сути в данных случаях слияние произошло путём переноса ссылки на коммит к другой ссылке. А значит для такой процедуры можно пользоваться также командами из раздела выше "ПЕРЕНОС ВЕТОК"

git reflog - покажет всю историю создания коммитов и переключения веток, по умолчанию с HEAD
git reflog название ветки - покажет всю историю создания коммитов и переключения веток по указанной ветке
git reflog --date=iso - выводит информацию с датой
!!! ВАЖНО: reflog хранит данные 90 дней, а если коммиты стали недостижимыми(при удалении ветки/ссылки несмерджинной), то всего 30 дней.
Рефлоги сохраняются только локально на нашем компе и к ним никто не будет иметь доступ.
===============================================
RESET ИЗМЕНЕНИЕ КОММИТОВ
git reset --hard идентификатор - перенесёт ссылку на указанный коммит. И при этом обновляет индекс и рабочую директорию на момент создания коммита, на который мы перешли. В результате чего эти зменения незакомичены. Соотвественно все незакоммиченные изменения исчезнут. Если после этого вызвать git status то будет выведена информация, что комитить нечего и это означает что индекс и директория соответствуют более старому состоянию репозитория.
!!! Это так называемый жёсткий ресет, при котором все незакоммиченные изменения исчезнут.
git reset --hard - !!! Если не указать идентификатор, то по умолчанию подразумевается HEAD и соответветственно мы никуда не предвигаемся и при этом все незакоммиченные измененения исчезнут. Это удобно,когда нужно просто удалить незакоммиченые изменения. Или удалить последний коммит - он станет недостижимым и будет удалён.

git reset --soft - Мягкий ресет не удаляет файлы в индексе и в рабочей директории. Если после этого вызвать git status то будут показаны индексированные, но незакоммиченные изменения на момент создания коммита, на который мы перешли.

git reset --soft @~ - переместит на один коммит назад
git commit -c ORIG_HEAD - создаст новый коммит с таким же названием какое было у комита ранее. В то же время старый коммит будет недостижимым и будет уалён
git commit --amend - переносит HEAD на предыдущий коммит, открывает редактор, которм мы може изменить или оставить название коммита и сохранет новый коммит. В то время коммит на котором мы дыли ранее становится не достижим и со временем будут удалён.
!!! Т.е. комманда делает в одну строку то что делают две комманды выше. Разница в том, что после --soft можно поставить любой идентификатор и соответветственно переставить куда угодно.

git reset - такая запись обозначает микс ресет, а это удаление файла из индекса и не затрагивает рабочую директорию. По умолчанию имеется ввиду HEAD
git reset путь - удалит указанный файл из индекса. Соответственно эта комманда может рассматриваться как противоположность команде git add путь.
=====================================================================
РАЗНИЦА МЕЖДУ КОММИТАМИ
git diff main feature - покажет разницу между main и fature
git diff...feature - покажет что именно изменилось в feature с момента отхождения от main
git diff идентификатор идентификатор - покажет разницу между указанными коммитами
git diff - покажет изменения между рабочей директорией и индексом
git diff HEAD - покажет измеменения между раб директорией и репозиторием, независимо от индекса
git diff --cached - покажет измемнения между индексом и репозиторием
git diff идентификатор - сравнит содержимое в рабочей директории по сравнению с репозиторием на момент указанного коммита.
!!!ВАЖНО git diff игнорирует непроиндексированные файлы(именно файлы, а не изменения), т.е. пока мы их не внесём в индекс мы их не увидим.
git diff путь к файлу - покажет изменения в файле
git diff . - в текущей директории целиком



